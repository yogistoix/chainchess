// The verifyProof function takes moveData and signature as arguments.
// It hashes moveData using Keccak-256, which is the hash function used in Ethereum.
// It prefixes the hash according to Ethereum's signature scheme.
// It splits signature into its components (r, s, and v).
// It uses ethUtil.ecrecover to recover the public key of the signer from the signature.
// It checks if the recovered public key matches the known public key of the Stockfish engine.
// It returns true if the signature is valid, false otherwise.
// This verifyProof function could be part of your off-chain code that interacts with the Stockfish engine and the on-chain smart contract.


const ethUtil = require('ethereumjs-util');

// Assuming the public key of the Stockfish engine is known and constant
const publicKey = Buffer.from('your_public_key_here', 'hex');

function verifyProof(moveData, signature) {
    // Hash the move data
    const moveHash = ethUtil.keccak256(moveData);

    // Prefix the hash according to Ethereum's signature scheme
    const prefixedHash = ethUtil.keccak256(
        Buffer.concat([
            Buffer.from("\x19Ethereum Signed Message:\n32"),
            moveHash
        ])
    );

    // Split the signature into its components (r, s, and v)
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const v = signature[64];

    // Recover the public key of the signer
    const recoveredPublicKey = ethUtil.ecrecover(
        prefixedHash,
        v,
        r,
        s
    );

    // Check if the recovered public key matches the known public key
    return ethUtil.publicToAddress(recoveredPublicKey).equals(publicKey);
}

// Usage:
const moveData = "e2e4";
const signature = ...;  // Assume this comes from the Stockfish engine
const isVerified = verifyProof(moveData, signature);
console.log(isVerified);  // Outputs true if the signature is valid, false otherwise

const Web3 = require('web3');
const ethUtil = require('ethereumjs-util');

// Assume web3 is connected to your Ethereum node
const web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

// Assume you have the ABI and address of your deployed smart contract
const chessGameABI = /* your smart contract ABI */;
const chessGameAddress = /* your smart contract address */;
const chessGameContract = new web3.eth.Contract(chessGameABI, chessGameAddress);

// Assume privateKey is the private key of the Stockfish engine
const privateKey = Buffer.from('your_private_key_here', 'hex');

async function submitMove(move) {
    // Sign the move data
    const moveHash = ethUtil.keccak256(move);
    const signature = ethUtil.ecsign(moveHash, privateKey);
    const signatureBytes = Buffer.concat([signature.r, signature.s, Buffer.from([signature.v])]);

    // Submit the move to the blockchain
    const accounts = await web3.eth.getAccounts();
    const senderAddress = accounts[0];  // Assume the first account is the sender

    await chessGameContract.methods.submitMove(move, signatureBytes.toString('hex')).send({ from: senderAddress });
}

// Usage:
submitMove("e2e4").catch(console.error);

// We're using web3.js to interact with the Ethereum blockchain and ethereumjs-util to sign data.
// We define a submitMove function that signs a chess move with the Stockfish engine's private key, then submits that move to your smart contract on the blockchain using the submitMove method of your smart contract.
// We assume the submitMove method of your smart contract is set up to accept a move and a signature, similar to the submitMove method in the Solidity code you've been working on.